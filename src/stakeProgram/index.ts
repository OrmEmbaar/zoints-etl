import { PrismaClient, StakeProgramSignature } from '@prisma/client';
import { Connection, ParsedConfirmedTransaction, PublicKey } from '@solana/web3.js';

import { log } from '../logger';
import { SolanaETL, UnprocessedSignature } from '../solana';
import { ETLParams } from '../types';
import { Instruction } from './instruction';

export * from './instruction';

/**
 * StakeProgramETL extracts, transforms and loads transactions generated by the
 * ZEE Stake program into the database.
 */
export default class StakeProgramETL extends SolanaETL {
    stakeProgramId: PublicKey;
    connection: Connection;
    prisma: PrismaClient;

    constructor(params: ETLParams, prisma: PrismaClient) {
        super(params, prisma);
        this.connection = params.connection;
        this.prisma = prisma;
        this.stakeProgramId = params.stakeProgramId;
    }

    /**
     * Inserts all new confirmed signatures into DB in chronological order.
     */
    private async syncSignatures(): Promise<void> {
        const res = await this.prisma.stakeProgramSignature.findFirst({
            orderBy: { id: 'desc' },
            rejectOnNotFound: false
        });

        const insert = async (data: UnprocessedSignature) => {
            return this.prisma.stakeProgramSignature.create({ data });
        };

        const inserted = await this.syncAccountSignatures(
            this.stakeProgramId,
            insert,
            res?.signature
        );

        if (inserted > 0) {
            log.info(`Found ${inserted} new stake program signatures`);
        }
    }

    private handleMissingTransaction(sig: StakeProgramSignature) {
        log.warn(`Missing transaction ${sig.signature}`);
        return this.prisma.stakeProgramSignature.update({
            where: { id: sig.id },
            data: { processed: true }
        });
    }

    private async syncInstructions(): Promise<void> {
        const getUnprocessedSigs = (batchSize: number) => {
            return this.prisma.stakeProgramSignature.findMany({
                take: batchSize,
                where: { processed: false },
                orderBy: { id: 'asc' }
            });
        };

        for await (const { tx, signature } of this.getUnprocessedPairs(getUnprocessedSigs)) {
            if (tx === null) {
                await this.handleMissingTransaction(signature);
                continue;
            }

            const parsedInstructions: Instruction[] = [];
            const instructions = this.formatAccountInstructions(tx, this.stakeProgramId);

            for (const { instruction, inner } of instructions) {
                const parsedInstruc = Instruction.new(signature.id, instruction, inner[0]);
                parsedInstructions.push(parsedInstruc);
            }

            await this.prisma.$transaction([
                this.prisma.stakeProgramSignature.update({
                    where: { id: signature.id },
                    data: {
                        processed: true,
                        fee: tx.meta?.fee,
                        recentBlockHash: tx.transaction.message.recentBlockhash
                    }
                }),
                ...parsedInstructions.map((i) => i.insert(this.prisma))
            ]);
        }
    }

    /**
     * Syncs the Stake program ETL.
     */
    async sync(): Promise<void> {
        await this.syncSignatures();
        await this.syncInstructions();
    }
}
