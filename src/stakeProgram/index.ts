import { PrismaClient, StakeProgramSignature } from '@prisma/client';
import { Connection, PublicKey } from '@solana/web3.js';

import { SolanaETL, UnprocessedSignature } from '../solana';
import { ETLParams } from '../types';
import { Instruction } from './instruction';

export * from './instruction';

/**
 * StakeProgramETL extracts, transforms and loads transactions generated by the
 * ZEE Stake program into the database.
 */
export default class StakeProgramETL extends SolanaETL {
    stakeProgramId: PublicKey;
    connection: Connection;
    prisma: PrismaClient;

    constructor(params: ETLParams, prisma: PrismaClient) {
        super(params, prisma);
        this.connection = params.connection;
        this.prisma = prisma;
        this.stakeProgramId = params.stakeProgramId;
    }

    /**
     * Inserts all new confirmed signatures into DB in chronological order.
     */
    private async syncSignatures(): Promise<void> {
        const res = await this.prisma.stakeProgramSignature.findFirst({
            orderBy: { id: 'desc' },
            rejectOnNotFound: false
        });
        const insert = async (data: UnprocessedSignature) => {
            return this.prisma.stakeProgramSignature.create({ data });
        };
        await this.syncAccountSignatures(this.stakeProgramId, insert, res?.signature);
    }

    /**
     *
     */
    private handleMissingTransaction(sig: StakeProgramSignature) {
        this.emit('warn', `Missing transaction ${sig.signature}`);
        return this.prisma.stakeProgramSignature.update({
            where: { id: sig.id },
            data: { processed: true }
        });
    }

    /**
     * Process newly synced signatures.
     */
    private async processSignatures(): Promise<void> {
        const getUnprocessedSigs = (batchSize: number) => {
            return this.prisma.stakeProgramSignature.findMany({
                take: batchSize,
                where: { processed: false },
                orderBy: { id: 'asc' }
            });
        };

        let count = 0;
        for await (const { tx, signature } of this.getUnprocessedPairs(getUnprocessedSigs)) {
            if (tx === null) {
                await this.handleMissingTransaction(signature);
                continue;
            }

            const parsedInstructions: Instruction[] = [];
            const instructions = this.formatAccountInstructions(tx, this.stakeProgramId);

            for (const { instruction, inner } of instructions) {
                const parsedInstruc = Instruction.new(signature.id, instruction, inner[0]);
                parsedInstructions.push(parsedInstruc);
                count++;
            }

            const signatureUpdate = {
                where: { id: signature.id },
                data: {
                    processed: true,
                    fee: tx.meta?.fee,
                    recentBlockHash: tx.transaction.message.recentBlockhash
                }
            };

            await this.prisma.$transaction([
                this.prisma.stakeProgramSignature.update(signatureUpdate),
                ...parsedInstructions.map((i) => i.insert(this.prisma))
            ]);
        }
        this.emit('newInstructions', count, this.stakeProgramId);
    }

    /**
     * Syncs the Stake program ETL.
     */
    async sync(): Promise<void> {
        await this.syncSignatures();
        await this.processSignatures();
    }
}
