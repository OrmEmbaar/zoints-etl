import { PrismaClient } from '@prisma/client';
import { Connection, PublicKey } from '@solana/web3.js';

import { log } from '../logger';
import { SolanaETL } from '../solana';
import { ETLParams } from '../types';
import { Instruction } from './instruction';

export * from './instruction';

/**
 * StakeProgramETL extracts, transforms and loads transactions generated by the
 * ZEE Stake program into the database.
 */
export default class StakeProgramETL extends SolanaETL {
    stakeProgramId: PublicKey;
    connection: Connection;
    prisma: PrismaClient;

    constructor(params: ETLParams, prisma: PrismaClient) {
        super(params, prisma);
        this.connection = params.connection;
        this.prisma = prisma;
        this.stakeProgramId = params.stakeProgramId;
    }

    /**
     * Processes new signature transactions.
     */
    private async processTransactions(): Promise<void> {
        let count = 0;

        const nextBatch = async (batchSize: number) => {
            return this.prisma.stakeProgramSignature.findMany({
                take: batchSize,
                where: { processed: false },
                orderBy: { id: 'asc' }
            });
        };

        for await (const u of this.generateUnprocessedTxs(nextBatch)) {
            const { tx, signature } = u;

            if (tx === null) {
                await this.handleMissingTransaction(signature.signature, signature.id);
                continue;
            }

            const parsedInstrucs: Instruction[] = [];
            const instructions = this.formatAccountInstructions(tx, this.stakeProgramId);

            for (const { outer, inner } of instructions) {
                const parsedInstruc = Instruction.new(signature.id, outer, inner[0]);
                parsedInstrucs.push(parsedInstruc);
            }

            await this.prisma.$transaction([
                this.prisma.stakeProgramSignature.update({
                    where: { id: signature.id },
                    data: {
                        processed: true,
                        fee: tx.meta?.fee,
                        recentBlockHash: tx.transaction.message.recentBlockhash
                    }
                }),
                ...parsedInstrucs.map((i) => i.insert(this.prisma))
            ]);

            count++;
        }

        if (count > 0) {
            log.info(`Processed ${count} new signatures`);
        }
    }

    /**
     * Inserts all new confirmed signatures into DB in chronological order.
     */
    private async gatherSignatures(): Promise<void> {
        let count = 0;

        const res = await this.prisma.stakeProgramSignature.findFirst({
            orderBy: { id: 'desc' },
            rejectOnNotFound: false
        });

        for await (const s of this.generateSignatures(this.stakeProgramId, res?.signature)) {
            // Signatures are confirmed so not expecting this to happen.
            if (!s.blockTime) {
                log.error(`Missing block time ${s.signature}`);
                continue;
            }
            await this.prisma.stakeProgramSignature.create({
                data: {
                    blockTime: new Date(s.blockTime * 1000),
                    signature: s.signature,
                    slot: s.slot,
                    memo: s.memo
                }
            });
            count++;
        }
        if (count > 0) {
            log.info(`Found ${count} new signatures`);
        }
    }

    /**
     * Syncs the Stake program ETL.
     */
    async sync(): Promise<void> {
        await this.gatherSignatures();
        await this.processTransactions();
    }
}
